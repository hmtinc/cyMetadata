/**
    Pathway Commons Central Data Cache

    Metadata Parser
    metadataParser.js

    Purpose  : To parse the subtree generated by the metadata parser
               into a human readable form

    Requires : Valid metadata subtree

    Effects  : Modifies the data structure of a node to be more human readable

    Note : Script may take time to parse metadata

    @author Harsh Mistry
    @version 1.1 2017/10/10
**/

//Returns all values mapped to a key in a given subtree
//Requires subtree to be valid
//Note : - A empty array is returned if no match is found
//       - Recurse indicates if other levels of the tree should be searched
function searchTree(subtree, key, recurse = true) {
  var result = []

  //Loop through all level nodes
  for (var i = 0; i < subtree.length; i++) {
    //Push current value if it matches
    if (subtree[i][0] == key) {
      result.push(subtree[i][1]);
    }

    //Recurse on subtree if one exists
    if (subtree[i][1] instanceof Array && recurse) {
      result.push(searchTree(subtree[i][1], key));
    }
  }

  return result;
}

//Search for just one entry
//Requires a valid subtree
function searchOne(subtree, key, name) {
  var temp = searchTree(subtree, key, false);
  if (temp.length > 0) return name + temp[0];
  else return null;
}

//Search for multiple entries
//Requires a valid subtree
function searchMultiple(subtree, key, name) {
  var temp = searchTree(subtree, key, false);
  if (temp) return ['name', temp];
  else return null;
}


//Search for a subnode
//Returns an array, a string, or null
//Requires a valid subtree
function searchForNode(subtree, key) {
  for (var i = 0; i < subtree.length; i++){
    if (subtree[i][0].indexOf(key) !== -1) return subtree[i][1];
  }
  return null;
}


//Returns a human readable array of metadata
//Requies subtree to be valid
//Note : null is returned if nothing can be parsed
function parse(subTree) {
  var result = [];
  var temp = [];

  //Stop id subtree is invalid
  if (!(subTree)) return null;

  //Get the entity reference object
  var eRef = searchForNode(subTree, 'bp:entityReference');


  if (eRef) {
    //Get the standard name
    result.push(searchOne(eRef, 'bp:standardName', 'Standard Name : '));

    //Get names
    result.push(searchMultiple(eRef, 'bp:name', 'Names'));

    //Get database ids
    result.push(searchMultiple(eRef, 'bp:xref', 'Database IDs'));
  }

  //Get data source
  var source = searchForNode(subTree, 'bp:dataSource');
  if (typeof source === 'string' ) result.push("Data Source : " + source);
  else if(source) result.push("Data Source : " + source[0][1]);

  //Get values if entity reference was not found
  if (!eRef){
    //Get BioPax Names
    result.push(searchMultiple(subTree, 'bp:name', 'Names'));

    //Get Biopax database id's
    result.push(["Database IDs", searchForNode(subTree, 'bp:xref')]);
  }


  //Get cellular location
  var location = searchForNode(subTree, 'bp:cellularLocation');
  if(location) {
    var term = searchForNode(location, 'bp:term');
    result.push('Cellular Location : ' + term); 
  }

  //Get all comments
  result.push(searchMultiple(subTree, 'bp:comment', 'Comments')); 

  //Remove all invalid values
  for (var i = 0; i < result.length; i++){
    if(!(result[i])){
      result.splice(i, 1);
    }
  }
  
  return result; 
}

//Export main function
module.exports = parse;

